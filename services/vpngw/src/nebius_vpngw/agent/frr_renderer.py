from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Dict, Any, List

BGPD_CONF = Path("/etc/frr/bgpd.conf")
FRR_CONF = Path("/etc/frr/frr.conf")
DAEMONS_FILE = Path("/etc/frr/daemons")


class FRRRenderer:
    def _ensure_bgpd_enabled(self) -> bool:
        """Ensure bgpd daemon is enabled; minimal edit of /etc/frr/daemons."""
        if not DAEMONS_FILE.exists():
            print("[FRR] WARNING: /etc/frr/daemons not found; creating with bgpd=yes")
            DAEMONS_FILE.parent.mkdir(parents=True, exist_ok=True)
            DAEMONS_FILE.write_text("bgpd=yes\n", encoding="utf-8")
            return True

        text = DAEMONS_FILE.read_text(encoding="utf-8").splitlines()
        seen = False
        new_lines: List[str] = []
        for line in text:
            if line.strip().startswith("bgpd="):
                new_lines.append("bgpd=yes")
                seen = True
            else:
                new_lines.append(line)
        if not seen:
            new_lines.append("bgpd=yes")
        if new_lines != text:
            DAEMONS_FILE.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
            print("[FRR] Enabled bgpd in /etc/frr/daemons")
            return True
        return False

    def render_and_apply(self, cfg: Dict[str, Any]) -> None:
        """Render FRR bgpd.conf for BGP tunnels and prefix advertisement.

        When routing_mode is bgp, configures neighbors for each active tunnel with APIPA link IPs.
        Advertises gateway.local_prefixes to neighbors where connection.bgp.advertise_local_prefixes=true.
        Supports hold/keepalive and graceful-restart defaults.
        """
        daemons_changed = self._ensure_bgpd_enabled()
        BGPD_CONF.parent.mkdir(parents=True, exist_ok=True)

        gateway = cfg.get("gateway", {})
        local_asn = gateway.get("local_asn", 65010)
        # Gateway-level local_prefixes: single source of truth for Nebius-side subnets
        gateway_local_prefixes: List[str] = gateway.get("local_prefixes", [])
        
        d_bgp = cfg.get("defaults", {}).get("routing", {}).get("bgp", {})
        hold = d_bgp.get("hold_time_seconds", 60)
        keep = d_bgp.get("keepalive_seconds", 20)
        router_id = d_bgp.get("router_id")
        graceful = d_bgp.get("graceful_restart", True)
        max_prefixes_default = d_bgp.get("max_prefixes", 1000)

        lines = [
            "! generated by nebius-vpngw-agent",
        ]
        
        # Track prefix-list filters for inbound BGP routes (optional whitelist)
        prefix_list_filters: Dict[str, List[str]] = {}  # neighbor_ip -> list of allowed prefixes
        
        # First pass: collect prefix-list filters
        for conn in cfg.get("connections", []):
            routing_mode = conn.get("routing_mode") or cfg.get("defaults", {}).get("routing", {}).get("mode", "bgp")
            if routing_mode != "bgp":
                continue
            conn_bgp = conn.get("bgp", {}) or {}
            conn_remote_prefixes = conn.get("remote_prefixes", []) or conn_bgp.get("remote_prefixes", []) or []
            
            for tun in conn.get("tunnels", []):
                if tun.get("ha_role", "active") != "active":
                    continue
                tbgp = tun.get("bgp", {}) or {}
                remote_ip = tbgp.get("remote_ip") or tun.get("inner_remote_ip")
                if remote_ip and conn_remote_prefixes:
                    prefix_list_filters[remote_ip] = conn_remote_prefixes
        
        # Define prefix-lists before router bgp section
        for neighbor_ip, allowed_prefixes in prefix_list_filters.items():
            list_name = f"ALLOW-FROM-{neighbor_ip.replace('.', '-')}"
            seq = 10
            for prefix in allowed_prefixes:
                lines.append(f"ip prefix-list {list_name} seq {seq} permit {prefix}")
                seq += 10
            lines.append("!")
        
        # Start router bgp configuration
        lines.append(f"router bgp {local_asn}")
            f" timers bgp {keep} {hold}",
        ]
        if router_id:
            lines.append(f" bgp router-id {router_id}")
        if graceful:
            lines.append(" bgp graceful-restart")
        # Disable policy requirement for eBGP (FRR 8.4+)
        lines.append(" no bgp ebgp-requires-policy")

        # Track which prefixes to advertise (can vary per connection)
        advertised_prefixes: set[str] = set()

        # Neighbors per active tunnel
        tunnel_index = 0  # Track VTI interface index for update-source
        for conn in cfg.get("connections", []):
            routing_mode = conn.get("routing_mode") or cfg.get("defaults", {}).get("routing", {}).get("mode", "bgp")
            if routing_mode != "bgp":
                continue
            
            # Check if this connection should advertise local prefixes
            conn_bgp = conn.get("bgp", {}) or {}
            advertise = conn_bgp.get("advertise_local_prefixes", True)  # Default: true
            remote_asn = conn_bgp.get("remote_asn")
            
            for tun in conn.get("tunnels", []):
                if tun.get("ha_role", "active") != "active":
                    continue
                tbgp = tun.get("bgp", {}) or {}
                local_ip = tbgp.get("local_ip") or tun.get("inner_local_ip")
                remote_ip = tbgp.get("remote_ip") or tun.get("inner_remote_ip")
                rasn = tbgp.get("remote_asn") or remote_asn
                if not (remote_ip and rasn):
                    continue
                
                lines.append(f" neighbor {remote_ip} remote-as {rasn}")
                lines.append(f" neighbor {remote_ip} timers {keep} {hold}")
                lines.append(f" neighbor {remote_ip} maximum-prefix {max_prefixes_default}")
                
                # CRITICAL: Configure update-source to use VTI interface IP
                # This ensures BGP packets use the correct source IP (APIPA inner IP)
                # instead of the primary interface IP (10.x.x.x)
                if local_ip:
                    vti_name = f"vti{tunnel_index}"
                    lines.append(f" neighbor {remote_ip} update-source {local_ip}")
                    print(f"[FRR] Configured neighbor {remote_ip} with update-source {local_ip} (via {vti_name})")
                
                tunnel_index += 1
                
                # Track prefixes to advertise for this connection
                if advertise:
                    advertised_prefixes.update(gateway_local_prefixes)

        # Advertise accumulated prefixes and activate neighbors
        lines.append(" !")
        lines.append(" address-family ipv4 unicast")
        for pfx in sorted(advertised_prefixes):
            lines.append(f"  network {pfx}")
        
        # Apply prefix-list filters to neighbors (if configured)
        for neighbor_ip in prefix_list_filters.keys():
            list_name = f"ALLOW-FROM-{neighbor_ip.replace('.', '-')}"
            lines.append(f"  neighbor {neighbor_ip} prefix-list {list_name} in")
        
        # Activate all neighbors in address-family
        for conn in cfg.get("connections", []):
            routing_mode = conn.get("routing_mode") or cfg.get("defaults", {}).get("routing", {}).get("mode", "bgp")
            if routing_mode != "bgp":
                continue
            for tun in conn.get("tunnels", []):
                if tun.get("ha_role", "active") != "active":
                    continue
                tbgp = tun.get("bgp", {}) or {}
                remote_ip = tbgp.get("remote_ip") or tun.get("inner_remote_ip")
                if remote_ip:
                    lines.append(f"  neighbor {remote_ip} activate")
        
        lines.append(" exit-address-family")

        rendered = "\n".join(lines) + "\n"
        # FRR 8+ uses integrated config in frr.conf
        FRR_CONF.write_text(rendered, encoding="utf-8")
        print(f"[FRR] Wrote bgp config with {len(advertised_prefixes)} advertised prefix(es)")
        # Reload bgpd to apply config (soft reload if only bgp changed; restart if daemons changed)
        cmd = ["systemctl", "restart" if daemons_changed else "reload", "frr"]
        try:
            subprocess.run(
                cmd,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=20,
            )
        except Exception:
            pass
