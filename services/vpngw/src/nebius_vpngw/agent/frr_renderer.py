from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Dict, Any, List

BGPD_CONF = Path("/etc/frr/bgpd.conf")
FRR_CONF = Path("/etc/frr/frr.conf")
DAEMONS_FILE = Path("/etc/frr/daemons")


class FRRRenderer:
    def _ensure_bgpd_enabled(self) -> bool:
        """Ensure bgpd daemon is enabled; minimal edit of /etc/frr/daemons."""
        if not DAEMONS_FILE.exists():
            print("[FRR] WARNING: /etc/frr/daemons not found; creating with bgpd=yes")
            DAEMONS_FILE.parent.mkdir(parents=True, exist_ok=True)
            DAEMONS_FILE.write_text("bgpd=yes\n", encoding="utf-8")
            return True

        text = DAEMONS_FILE.read_text(encoding="utf-8").splitlines()
        seen = False
        new_lines: List[str] = []
        for line in text:
            if line.strip().startswith("bgpd="):
                new_lines.append("bgpd=yes")
                seen = True
            else:
                new_lines.append(line)
        if not seen:
            new_lines.append("bgpd=yes")
        if new_lines != text:
            DAEMONS_FILE.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
            print("[FRR] Enabled bgpd in /etc/frr/daemons")
            return True
        return False

    def render_and_apply(self, cfg: Dict[str, Any]) -> None:
        """Render FRR bgpd.conf for BGP tunnels and prefix advertisement.

        When routing_mode is bgp, configures neighbors for each active tunnel with APIPA link IPs.
        Advertises gateway.local_prefixes to neighbors where connection.bgp.advertise_local_prefixes=true.
        Supports hold/keepalive and graceful-restart defaults.
        """
        daemons_changed = self._ensure_bgpd_enabled()
        BGPD_CONF.parent.mkdir(parents=True, exist_ok=True)

        gateway = cfg.get("gateway", {})
        local_asn = gateway.get("local_asn", 65010)
        # Gateway-level local_prefixes: single source of truth for Nebius-side subnets
        gateway_local_prefixes: List[str] = gateway.get("local_prefixes", [])
        
        d_bgp = cfg.get("defaults", {}).get("routing", {}).get("bgp", {})
        hold = d_bgp.get("hold_time_seconds", 60)
        keep = d_bgp.get("keepalive_seconds", 20)
        router_id = d_bgp.get("router_id")
        graceful = d_bgp.get("graceful_restart", True)
        max_prefixes_default = d_bgp.get("max_prefixes", 1000)

        lines = [
            "! generated by nebius-vpngw-agent",
            f"router bgp {local_asn}",
            f" bgp keepalive {keep}",
            f" bgp holdtime {hold}",
        ]
        if router_id:
            lines.append(f" bgp router-id {router_id}")
        if graceful:
            lines.append(" bgp graceful-restart")

        # Track which prefixes to advertise (can vary per connection)
        advertised_prefixes: set[str] = set()

        # Neighbors per active tunnel
        for conn in cfg.get("connections", []):
            routing_mode = conn.get("routing_mode") or cfg.get("defaults", {}).get("routing", {}).get("mode", "bgp")
            if routing_mode != "bgp":
                continue
            
            # Check if this connection should advertise local prefixes
            conn_bgp = conn.get("bgp", {}) or {}
            advertise = conn_bgp.get("advertise_local_prefixes", True)  # Default: true
            remote_asn = conn_bgp.get("remote_asn")
            
            for tun in conn.get("tunnels", []):
                if tun.get("ha_role", "active") != "active":
                    continue
                tbgp = tun.get("bgp", {}) or {}
                _local_ip = tbgp.get("local_ip") or tun.get("inner_local_ip")  # Reserved for future use
                remote_ip = tbgp.get("remote_ip") or tun.get("inner_remote_ip")
                rasn = tbgp.get("remote_asn") or remote_asn
                if not (remote_ip and rasn):
                    continue
                
                lines.append(f" neighbor {remote_ip} remote-as {rasn}")
                lines.append(f" neighbor {remote_ip} timers {keep} {hold}")
                lines.append(f" neighbor {remote_ip} maximum-prefix {max_prefixes_default}")
                
                # Track prefixes to advertise for this connection
                if advertise:
                    advertised_prefixes.update(gateway_local_prefixes)

        # Advertise accumulated prefixes
        for pfx in sorted(advertised_prefixes):
            lines.append(f" network {pfx}")

        rendered = "\n".join(lines) + "\n"
        BGPD_CONF.write_text(rendered, encoding="utf-8")
        print(f"[FRR] Wrote bgp config with {len(advertised_prefixes)} advertised prefix(es)")
        # Reload bgpd to apply config (soft reload if only bgp changed; restart if daemons changed)
        cmd = ["systemctl", "restart" if daemons_changed else "reload", "frr"]
        try:
            subprocess.run(
                cmd,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=20,
            )
        except Exception:
            pass
