from __future__ import annotations

from pathlib import Path
from typing import Dict, Any, List

IPSEC_CONF = Path("/etc/ipsec.conf")
IPSEC_SECRETS = Path("/etc/ipsec.secrets")


class StrongSwanRenderer:
    def render_and_apply(self, cfg: Dict[str, Any]) -> None:
        """Render strongSwan config based on resolved per-VM YAML.

        Generates ipsec.conf with one connection per active tunnel and ipsec.secrets for PSKs.
        Uses VTI (xfrm interface) naming pattern: vti<N> per tunnel index.
        """
        connections: List[Dict[str, Any]] = []
        secrets_lines: List[str] = []

        defaults = cfg.get("defaults", {})
        global_ike_version = defaults.get("ike_version", 2)
        allow_ikev1 = defaults.get("allow_ikev1", True)
        crypto_defaults = defaults.get("crypto", {})

        idx = 0
        for conn in cfg.get("connections", []):
            routing_mode = conn.get("routing_mode") or cfg.get("defaults", {}).get("routing", {}).get("mode", "bgp")
            for tun in conn.get("tunnels", []):
                if tun.get("ha_role", "active") != "active":
                    continue
                name = f"tunnel{idx}"
                ike_version = tun.get("ike_version", global_ike_version)
                inner_local_ip = tun.get("inner_local_ip")
                inner_remote_ip = tun.get("inner_remote_ip")
                inner_cidr = tun.get("inner_cidr")
                psk = tun.get("psk")

                # Proposals
                ccrypto = tun.get("crypto", {}) or {}
                ike_props = ccrypto.get("ike_proposals") or crypto_defaults.get("ike_proposals", [])
                esp_props = ccrypto.get("esp_proposals") or crypto_defaults.get("esp_proposals", [])
                ike_life = ccrypto.get("ike_lifetime_seconds") or crypto_defaults.get("ike_lifetime_seconds")
                esp_life = ccrypto.get("esp_lifetime_seconds") or crypto_defaults.get("esp_lifetime_seconds")

                # Build connection stanza (using charon, v2 preferred)
                conn_lines = [f"conn {name}"]
                # left/right underlay IPs are determined by system routing; we focus on VTI setup via updown if needed
                # Configure IKE version
                if ike_version == 2:
                    conn_lines.append("    keyexchange=ikev2")
                elif ike_version == 1 and allow_ikev1:
                    conn_lines.append("    keyexchange=ikev1")
                else:
                    continue  # unsupported combination

                # Proposals
                if ike_props:
                    conn_lines.append(f"    ike={';'.join(ike_props)}")
                if esp_props:
                    conn_lines.append(f"    esp={';'.join(esp_props)}")
                if ike_life:
                    conn_lines.append(f"    ikelifetime={int(ike_life)}s")
                if esp_life:
                    conn_lines.append(f"    keylife={int(esp_life)}s")

                # DPD defaults
                dpd = defaults.get("dpd", {})
                if dpd:
                    conn_lines.append(f"    dpddelay={int(dpd.get('interval_seconds', 30))}s")
                    conn_lines.append(f"    dpdtimeout={int(dpd.get('timeout_seconds', 120))}s")
                    conn_lines.append("    dpdaction=restart")

                # VTI: simplified policy-based setup; full VTI requires updown scripts. For scaffold, set mark.
                if routing_mode == "bgp":
                    conn_lines.append("    type=tunnel")
                else:
                    conn_lines.append("    type=tunnel")

                # Left/right identification: placeholders; in production set left/rightsubnet or left/rightid.
                if inner_cidr:
                    conn_lines.append(f"    leftsubnet={inner_cidr}")
                if inner_remote_ip:
                    conn_lines.append(f"    rightsourceip={inner_remote_ip}")

                conn_lines.append("    auto=add")
                connections.append("\n".join(conn_lines))

                if psk:
                    secrets_lines.append(f": PSK \"{psk}\"")

                idx += 1

        conf_text = [
            "# generated by nebius-vpngw-agent",
            "config setup",
            "    charondebug=\"ike 1, knl 1, net 1, cfg 1\"",
            "",
        ] + connections

        IPSEC_CONF.write_text("\n".join(conf_text) + "\n", encoding="utf-8")
        IPSEC_SECRETS.write_text("\n".join(secrets_lines) + "\n", encoding="utf-8")
        print("[StrongSwan] Wrote ipsec.conf and ipsec.secrets")
        # In production: run `ipsec reload` or `swanctl --load-all`
